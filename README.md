# rrt-cpp
Implementation of RRT with C++ for Mowito challenge. My implementation of RRT is on the branch rrt. 

## Overview of Files
The main RRT code is stored in rrt.cpp, with the header file rrt.h. 
There are 4 default maps of varying sizes. The code can also be tested on a random map, generated by random_map_generator. 
main.cpp is used to take in the inputs of the map file and run the code. The map is in the form of a .txt file with x_size, y_size and an occupancy grid of 0s and 1s where 0 is free space and 1 is an obstacle. The main function reads the map file and passes it to the planner as a map object which consists of the size and a vector of vector of ints with the occupancy grid. 
The planner will print an output that elaborates if it is a success or failure. The output of the planner is written to output.txt, which is used by visualizer.py to visualize the plot. If the planner does not reach the goal, the path is just the start position of the robot. 
Example output plots can be seen in the results folder.

## Compile and Run Code:
```bash
g++ main.cpp rrt.cpp -o rrt_test #compiles RRT code
./rrt_test map4.txt 200 200 300 300 #run in the following format - ./rrt_test map_name start_x start_y goal_x goal_y
python visualizer.py #run this to plot a graph, will be prompted to enter map filename. Enter the full name - eg. map4.txt
```

## Notes on Implementation
RRT is set up as a class which takes in a map, start position and goal position. These starts and goals are entered by the user or set to a default of (0,0), (10,10). 
A custom struct point is defined for each set of (x, y). The tree is maintained as a vector of points. An index in the tree is used to access every point. An unordered map is used to maintain the parent of each node. For example, parent[i] will return the parent of i. In accordance with the basic RRT algorithm, the parent is the nearest node, or in the unordered map, the index of the nearest node. The distance between nodes is the Euclidean distance between map indices. It is assumed that the robot can move freely within an 8-connected grid. 

After a random sample is drawn, the RRT algorithm will attempt to extend from the start to the sample with a pre-defined step length. The step length is set by default to 1.0, but is set to 3.0 in the current implementation. The new point will only be added to the tree if the algorithm is able to extend without encountering any obstacles. The checkValidEdge function is used for extension. It calls on checkValidPoint which checks that the point is not in an obstacle and within map bounds. 

The goal condition is met when: 
1. The last point in the tree (the latest succesfully extended sample) is within a certain radius of the goal.
2. There is a valid edge between the last point in the tree and the goal.
   
## Test Cases
I have tested the planner with the default 4 maps, generated with arbitrary obstacles. The code should perform well on any map and can be tested on random maps. 

The file random_map_generator.py is used to generate arbitrary maps. 
```bash
python generate_map.py <x_size> <y_size> <num_obstacles>
```
The script utilizes the NumPy library to create a two-dimensional array representing the map. The map's size, defined by x_size and y_size, and the number of obstacles (num_obstacles) are taken as command-line inputs. By default, 80% of the map is designated as free space, while the remaining area is randomly populated with obstacles of varying sizes. The generated map data is then saved to a text file named random_map.txt. 


## Possible Improvements
Possible improvements include implementing RRT* and using a KD-Tree or similar structure for nearest neighbor search. 
To make it more generalizable, I would consider using a nav_msg/occupancy_grid for ROS integration. This can be done without much change to the code. 
